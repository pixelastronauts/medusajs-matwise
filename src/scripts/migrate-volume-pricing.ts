/**
 * Migration script: Migrate volume pricing from variant metadata to the new volume-pricing module
 * 
 * Usage:
 *   npx medusa exec src/scripts/migrate-volume-pricing.ts
 * 
 * Options:
 *   --dry-run    Preview what would be migrated without making changes
 *   --product-id Migrate only a specific product
 * 
 * Example:
 *   npx medusa exec src/scripts/migrate-volume-pricing.ts --dry-run
 *   npx medusa exec src/scripts/migrate-volume-pricing.ts --product-id=prod_01ABC123
 */

import { ExecArgs } from "@medusajs/framework/types";
import { Modules } from "@medusajs/framework/utils";
import { VOLUME_PRICING_MODULE } from "../modules/volume-pricing";

export default async function migrateVolumePricing({ container }: ExecArgs) {
  const logger = container.resolve("logger");
  const productModuleService = container.resolve(Modules.PRODUCT);
  const volumePricingService = container.resolve(VOLUME_PRICING_MODULE) as any;

  // Parse command line arguments
  const args = process.argv.slice(2);
  const dryRun = args.includes("--dry-run");
  const productIdArg = args.find((arg) => arg.startsWith("--product-id="));
  const productId = productIdArg?.split("=")[1];

  logger.info("=".repeat(60));
  logger.info("Volume Pricing Migration Script");
  logger.info("=".repeat(60));
  logger.info(`Mode: ${dryRun ? "DRY RUN (no changes will be made)" : "LIVE"}`);
  logger.info(`Product filter: ${productId || "All products"}`);
  logger.info("");

  try {
    // Fetch products
    let products: any[];

    if (productId) {
      const product = await productModuleService.retrieveProduct(productId, {
        relations: ["variants"],
      });
      products = product ? [product] : [];
    } else {
      products = await productModuleService.listProducts({}, {
        relations: ["variants"],
      });
    }

    logger.info(`Found ${products.length} product(s) to process`);

    let totalVariantsProcessed = 0;
    let totalVariantsMigrated = 0;
    let totalVariantsSkipped = 0;
    let totalTiersCreated = 0;

    for (const product of products) {
      logger.info(`\nProcessing product: ${product.title} (${product.id})`);

      for (const variant of product.variants || []) {
        totalVariantsProcessed++;

        // Skip custom variants (generated by the customizer)
        if (variant.metadata?.custom === true) {
          logger.debug(`  Skipping custom variant: ${variant.title} (${variant.id})`);
          totalVariantsSkipped++;
          continue;
        }

        // Get metadata tiers
        const metadataTiers = variant.metadata?.volume_pricing_tiers as
          | { minQty: number; maxQty: number | null; pricePerSqm: number }[]
          | undefined;

        if (!metadataTiers || metadataTiers.length === 0) {
          logger.debug(`  No metadata tiers for: ${variant.title} (${variant.id})`);
          totalVariantsSkipped++;
          continue;
        }

        // Check if already migrated
        const existingTiers = await volumePricingService.getTiersForVariant(
          variant.id,
          null
        );

        if (existingTiers && existingTiers.length > 0) {
          logger.info(`  Already migrated: ${variant.title} (${variant.id}) - ${existingTiers.length} tiers exist`);
          totalVariantsSkipped++;
          continue;
        }

        logger.info(`  Migrating: ${variant.title} (${variant.id})`);
        logger.info(`    Found ${metadataTiers.length} tier(s) in metadata:`);

        for (const tier of metadataTiers) {
          logger.info(
            `      - Qty ${tier.minQty}-${tier.maxQty || "∞"}: €${tier.pricePerSqm}/m²`
          );
        }

        if (!dryRun) {
          // Perform migration
          const newTiers = await volumePricingService.migrateFromMetadata(
            variant.id,
            metadataTiers
          );

          totalTiersCreated += newTiers.length;
          logger.info(`    ✓ Created ${newTiers.length} tier(s) in new module`);
        } else {
          totalTiersCreated += metadataTiers.length;
          logger.info(`    [DRY RUN] Would create ${metadataTiers.length} tier(s)`);
        }

        totalVariantsMigrated++;
      }
    }

    // Summary
    logger.info("\n" + "=".repeat(60));
    logger.info("Migration Summary");
    logger.info("=".repeat(60));
    logger.info(`Products processed: ${products.length}`);
    logger.info(`Variants processed: ${totalVariantsProcessed}`);
    logger.info(`Variants migrated: ${totalVariantsMigrated}`);
    logger.info(`Variants skipped: ${totalVariantsSkipped}`);
    logger.info(`Tiers created: ${totalTiersCreated}`);
    logger.info(`Mode: ${dryRun ? "DRY RUN (no changes made)" : "LIVE (changes applied)"}`);
    logger.info("=".repeat(60));

    if (dryRun) {
      logger.info("\nTo perform the actual migration, run without --dry-run:");
      logger.info("  npx medusa exec src/scripts/migrate-volume-pricing.ts");
    } else {
      logger.info("\nMigration complete!");
      logger.info("Note: The old metadata tiers are still in place. You can safely remove them");
      logger.info("after verifying the new module is working correctly.");
    }
  } catch (error: any) {
    logger.error("Migration failed:", error.message);
    throw error;
  }
}




